"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_path_1 = require("node:path");
const extract_styles_1 = require("../postcss/extract-styles");
const append_variables_1 = require("./transforms/append-variables");
const append_import_1 = require("./transforms/append-import");
const visitor_1 = require("./visitor");
const allowed_paths_1 = require("./utils/allowed-paths");
const get_tailwind_config_1 = require("./utils/get-tailwind-config");
function rootVisitor(options, cwd) {
    const errors = [];
    const tailwindConfigPath = (0, node_path_1.resolve)(cwd, options.tailwindConfigPath || "./tailwind.config.js");
    const tailwindConfig = (0, get_tailwind_config_1.getTailwindConfig)(tailwindConfigPath, {
        ...options,
        onError(error) {
            errors.push(error);
        },
    });
    const { allowModuleTransform, allowRelativeModules } = (0, allowed_paths_1.getAllowedOptions)(tailwindConfig, options);
    return {
        visitor: {
            Program: {
                enter(path, state) {
                    if (!(0, allowed_paths_1.isAllowedProgramPath)({
                        path: state.filename,
                        allowRelativeModules,
                        cwd,
                    })) {
                        return;
                    }
                    let canCompile = true;
                    let canTransform = true;
                    switch (state.opts.mode) {
                        case "compileOnly": {
                            canTransform = false;
                            break;
                        }
                        case "transformOnly": {
                            canCompile = false;
                            break;
                        }
                    }
                    const visitorState = {
                        cwd,
                        rem: 16,
                        platform: "native",
                        hmr: true,
                        mode: "compileAndTransform",
                        blockModuleTransform: [],
                        hasStyledComponentImport: false,
                        canCompile,
                        canTransform,
                        ...state,
                        ...state.opts,
                        allowModuleTransform,
                        allowRelativeModules,
                        blockList: new Set(),
                        hasProvider: false,
                        hasStyleSheetImport: false,
                        tailwindConfig,
                        tailwindConfigPath,
                    };
                    // Traverse the file
                    path.traverse(visitor_1.visitor, visitorState);
                    const { filename, hasStyleSheetImport, hasProvider, hasStyledComponentImport, hmr, } = visitorState;
                    if (hmr) {
                        /**
                         * Override tailwind to only process the classnames in this file
                         */
                        const { styles } = (0, extract_styles_1.extractStyles)({
                            ...tailwindConfig,
                            content: [filename],
                            // If the file doesn't have any Tailwind styles, it will print a warning
                            // We force an empty style to prevent this
                            safelist: ["babel-empty"],
                        });
                        const bodyNode = path.node.body;
                        if (!hasStyledComponentImport && canTransform) {
                            (0, append_import_1.prependImport)(bodyNode, "StyledComponent", "tailwindcss-react-native");
                        }
                        // If there are no styles, early exit
                        if (Object.keys(styles).length === 0)
                            return;
                        (0, append_variables_1.appendVariables)(bodyNode, styles);
                        if (!hasStyleSheetImport) {
                            (0, append_import_1.prependImport)(bodyNode, ["RNStyleSheet", "StyleSheet"], "react-native");
                        }
                    }
                    else {
                        if (!hasProvider) {
                            return;
                        }
                        /**
                         * Override tailwind to only process the classnames in this file
                         */
                        const { styles } = (0, extract_styles_1.extractStyles)(tailwindConfig);
                        // If there are no styles, early exit
                        if (Object.keys(styles).length === 0)
                            return;
                        const bodyNode = path.node.body;
                        (0, append_variables_1.appendVariables)(bodyNode, styles);
                        if (!hasStyleSheetImport) {
                            (0, append_import_1.prependImport)(bodyNode, ["RNStyleSheet", "StyleSheet"], "react-native");
                        }
                    }
                },
            },
        },
    };
}
exports.default = rootVisitor;
